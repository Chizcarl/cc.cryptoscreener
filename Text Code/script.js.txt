document.addEventListener('DOMContentLoaded', () => {
    // --- General Elements (Exist for All Users) ---
    const bodyElement = document.body;
    const sidebar = document.getElementById('settings-sidebar');
    const sidebarToggle = document.getElementById('sidebar-toggle');
    const screenerTableBody = document.getElementById('screener-table-body');
    const statusBar = document.getElementById('status-bar');
    const loadingOverlay = document.getElementById('loading-overlay');
    const applyAlphaFilterButton = document.getElementById('apply-alpha-filter');
    const refreshDataButton = document.getElementById('refresh-data');
    const tickerViewModeSelect = document.getElementById('ticker-view-mode');
    const tickerTapeContainer = document.getElementById('ticker-tape-container');
    const tickerTapeWidgetContainer = document.getElementById('tradingview-ticker-widget-container');
    const gradeModalOverlay = document.getElementById('gradeModal');
    const gradeModalItemName = document.getElementById('grade-modal-item-name');
    const gradeSelect = document.getElementById('gradeSelect');
    const confirmGradeButton = document.getElementById('confirmGradeButton');
    const gradeModalCloseButtons = gradeModalOverlay.querySelectorAll('.modal-close-button, .modal-cancel-button');
    const chartModalOverlay = document.getElementById('chartModal');
    const chartModalTitle = document.getElementById('chart-modal-title');
    const chartWidgetContainer = document.getElementById('tradingview-widget-container-dynamic');
    const infoPanelContainer = document.getElementById('pair-info-container');
    const infoPanelToggle = document.getElementById('toggle-info-panel');
    const chartModalCloseButtons = chartModalOverlay.querySelectorAll('.modal-close-button');
    const openTvSiteButton = document.getElementById('open-tv-site-button');
    const tabNav = document.getElementById('mainTabNav');
    const tabLinks = tabNav.querySelectorAll('.tab-link');
    const tabPanels = document.querySelectorAll('.tab-panel');
    const contextMenu = document.getElementById('context-menu');
    const contextAddWatchlist = document.getElementById('context-add-watchlist');
    const contextDeleteWatchlist = document.getElementById('context-delete-watchlist');

    // --- Variables ---
    let fullScreenerData = [];
    let currentWatchlistData = [];
    let sortColumnIndex = -1;
    let sortAscending = true;
    let contextTargetRow = null;
    let contextTargetTable = null;
    let activeModalConfirmCallback = null;
    let tradingViewChartInstance = null;
    let currentChartSymbol = '';
    let lastSortedTableId = null;
    let lastSortedHeader = null;

    // Use IS_AUTHENTICATED (defined in inline script in HTML)
    const isAuthenticated = typeof IS_AUTHENTICATED !== 'undefined' ? IS_AUTHENTICATED : false;

    // --- Watchlist-Specific Elements (Declared here, assigned if authenticated) ---
    let watchlistTableBody = null;
    let watchlistCountSpan = null;
    let watchlistFilterInput = null;
    let watchlistClearFilterButton = null;
    let copyWatchlistButton = null;
    let deleteAllWatchlistButton = null;

    if (isAuthenticated) {
        watchlistTableBody = document.getElementById('watchlist-table-body');
        watchlistCountSpan = document.getElementById('watchlist-count');
        watchlistFilterInput = document.getElementById('watchlist-date-filter');
        watchlistClearFilterButton = document.getElementById('watchlist-clear-filter');
        copyWatchlistButton = document.getElementById('copy-watchlist');
        deleteAllWatchlistButton = document.getElementById('delete-all-watchlist');
    }

    // --- Helper Functions ---
    const showLoading = (show) => loadingOverlay.classList.toggle('visible', show);
    const updateStatus = (message, isError = false) => { statusBar.textContent = message; statusBar.classList.toggle('error', isError); setTimeout(() => { if (statusBar.textContent === message) { statusBar.textContent = 'Ready'; statusBar.classList.remove('error'); } }, 5000); };
    const fetchData = async (url, options = {}) => {
        showLoading(true);
        try { const response = await fetch(url, options); if (!response.ok) { const errorData = await response.json().catch(() => ({ message: `HTTP error! ${response.status}` })); throw new Error(errorData.message || `HTTP error! ${response.status}`); } const contentType = response.headers.get("content-type"); if (contentType && contentType.indexOf("application/json") !== -1) return await response.json(); else throw new Error("Non-JSON response");
        } catch (error) { console.error(`Fetch error for ${url}:`, error); updateStatus(`Error: ${error.message}`, true); return null; }
        finally { showLoading(false); }
     };

    // --- Define Event Handlers EARLY ---
    const handleDoubleClick = (event) => {
        const pairName = event.currentTarget.dataset.name;
        if (pairName) {
            navigator.clipboard.writeText(pairName)
                .then(() => updateStatus(`Copied ${pairName}.`))
                .catch(err => updateStatus(`Copy failed.`, true));
        }
    };

    const hideContextMenu = () => {
        if (contextMenu.style.display === 'block') {
            contextMenu.style.display = 'none';
            contextTargetRow = null;
            contextTargetTable = null;
            document.removeEventListener('click', hideContextMenuOnClickOutside);
            document.removeEventListener('contextmenu', hideContextMenuOnClickOutside);
        }
    };

    const hideContextMenuOnClickOutside = (event) => {
        if (!contextMenu.contains(event.target)) {
            hideContextMenu();
        } else {
            // Re-add listener if click was inside menu, to close on next outside click
            document.addEventListener('click', hideContextMenuOnClickOutside, { once: true });
            document.addEventListener('contextmenu', hideContextMenuOnClickOutside, { once: true });
        }
    };

    const handleContextMenu = (event) => {
        event.preventDefault();
        hideContextMenu(); // Close any existing menu
        contextTargetRow = event.currentTarget;
        contextTargetTable = contextTargetRow.closest('table').id === 'screener-table' ? 'screener' : 'watchlist';

        // Determine which actions are available based on context and authentication
        const showAdd = isAuthenticated && contextTargetTable === 'screener';
        const showDelete = isAuthenticated && contextTargetTable === 'watchlist';
        const showOpenChart = true; // Always show chart
        const showCopyName = true; // Always show copy

        if (contextAddWatchlist) contextAddWatchlist.style.display = showAdd ? 'flex' : 'none';
        if (contextDeleteWatchlist) contextDeleteWatchlist.style.display = showDelete ? 'flex' : 'none';

        // Only display the menu if at least one action is available
        if (!showAdd && !showDelete && !showOpenChart && !showCopyName) return;

        // Position and show the menu
        const menuWidth = contextMenu.offsetWidth;
        const menuHeight = contextMenu.offsetHeight;
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        let x = event.clientX;
        let y = event.clientY;
        if (x + menuWidth > windowWidth) x = windowWidth - menuWidth - 5;
        if (y + menuHeight > windowHeight) y = windowHeight - menuHeight - 5;
        contextMenu.style.top = `${y}px`;
        contextMenu.style.left = `${x}px`;
        contextMenu.style.display = 'block';

        // Add listeners to close the menu
        document.addEventListener('click', hideContextMenuOnClickOutside, { once: true });
        document.addEventListener('contextmenu', hideContextMenuOnClickOutside, { once: true });
    };
    // --- End Define Event Handlers ---


    // --- Initial Setup ---
    if (sidebarToggle && sidebar) {
        sidebarToggle.addEventListener('click', () => {
            const isCollapsed = sidebar.classList.toggle('collapsed');
            localStorage.setItem('sidebarIsCollapsed', isCollapsed);
        });
        if (localStorage.getItem('sidebarIsCollapsed') === 'false') {
            sidebar.classList.remove('collapsed');
        } else {
            sidebar.classList.add('collapsed');
        }
    }

    // --- Rendering Functions ---
    const renderRatingBar = (rating) => { const numRating = Number(rating); const clampedRating = isNaN(numRating) ? 0 : Math.max(0, Math.min(5, numRating)); const maxSegments = 5; let segmentsHTML = `<span class="rating-bar-container" title="Rating: ${clampedRating}/5">`; for (let i = 1; i <= maxSegments; i++) { const filledClass = i <= clampedRating ? `filled level-${clampedRating}` : ''; segmentsHTML += `<span class="rating-segment ${filledClass}"></span>`; } segmentsHTML += '</span>'; return segmentsHTML; };
    const safeSort = (data, key, ascending = true) => { return [...data].sort((a, b) => { let valA = a[key]; let valB = b[key]; const isNumA = typeof valA === 'number' && !isNaN(valA); const isNumB = typeof valB === 'number' && !isNaN(valB); if (valA === null || valA === undefined) valA = ascending ? Infinity : -Infinity; if (valB === null || valB === undefined) valB = ascending ? Infinity : -Infinity; if (isNumA && isNumB) { return ascending ? valA - valB : valB - valA; } else { const comparison = String(valA).localeCompare(String(valB), undefined, { sensitivity: 'base' }); return ascending ? comparison : -comparison; } }); };

    // --- Ticker Tape ---
    const updateTickerTape = () => {
        if (!tickerTapeWidgetContainer || !tickerViewModeSelect || typeof TradingView === 'undefined' || !fullScreenerData) { if(tickerTapeWidgetContainer) tickerTapeWidgetContainer.innerHTML = '<div class="widget-placeholder">Ticker unavailable</div>'; return; }
        const viewMode = tickerViewModeSelect.value;
        let symbols = []; const createSymbolObject = item => ({ proName: `BYBIT:${item.name}`, title: item.name.replace(/USDT(\.P)?$/i, '') });
        let dataForTicker = [...fullScreenerData];
        switch(viewMode) {
            case 'top_rating': symbols = safeSort(dataForTicker, 'rating', false).slice(0, 10).map(createSymbolObject); break;
            case 'bottom_rating': symbols = safeSort(dataForTicker, 'rating', true).slice(0, 10).map(createSymbolObject); break;
            case 'top_rsi': symbols = safeSort(dataForTicker, 'RSI_original', false).slice(0, 10).map(createSymbolObject); break;
            case 'bottom_rsi': symbols = safeSort(dataForTicker, 'RSI_original', true).slice(0, 10).map(createSymbolObject); break;
            case 'all_screener': default: symbols = dataForTicker.slice(0, 20).map(createSymbolObject); break;
        }
        if (symbols.length === 0 && viewMode !== 'all_screener') { symbols = [ { "proName": "BYBIT:BTCUSDT", "title": "BTC" }]; }
        tickerTapeWidgetContainer.innerHTML = '';
        const script = document.createElement('script'); script.type = 'text/javascript'; script.src = 'https://s3.tradingview.com/external-embedding/embed-widget-ticker-tape.js'; script.async = true;
        const widgetConfig = { "container_id": tickerTapeWidgetContainer.id, "symbols": symbols, "showSymbolLogo": true, "isTransparent": true, "displayMode": "regular", "colorTheme": "dark", "locale": "en" };
        script.text = JSON.stringify(widgetConfig);
        if(document.getElementById(tickerTapeWidgetContainer.id)) {
             tickerTapeWidgetContainer.appendChild(script);
        }
    };

    // --- Table Population (Now Uses Defined Handlers) ---
    const populateScreenerTable = (tbodyElement, data, columnKeys) => {
        tbodyElement.innerHTML = ''; const colCount = columnKeys.length + 1;
        if (!data || data.length === 0) { tbodyElement.innerHTML = `<tr><td colspan="${colCount}" class="placeholder">No data available.</td></tr>`; return; }
        const fragment = document.createDocumentFragment();
        data.forEach(item => {
            const row = document.createElement('tr'); row.dataset.name = item.name;
            columnKeys.forEach((key) => { const cell = row.insertCell(); if (key === 'rating') { cell.innerHTML = renderRatingBar(item[key] ?? 0); cell.classList.add('rating-cell'); } else { cell.textContent = item[key] ?? 'N/A'; } });
            const actionCell = row.insertCell(); actionCell.classList.add('table-actions');
            const addBtnDisabled = !IS_AUTHENTICATED ? 'disabled title="Login to add to watchlist"' : 'title="Add to Watchlist"';
            actionCell.innerHTML = `<button class="button-icon action-add" data-name="${item.name}" ${addBtnDisabled}><svg><use xlink:href="#icon-add-circle"></use></svg></button><button class="button-icon action-chart" title="Open Chart" data-name="${item.name}"><svg><use xlink:href="#icon-chart"></use></svg></button>`;
            // Use already defined handlers
            row.addEventListener('dblclick', handleDoubleClick);
            row.addEventListener('contextmenu', handleContextMenu);
            fragment.appendChild(row);
        });
        tbodyElement.appendChild(fragment);
    };

    const populateWatchlistTable = (tbodyElement, data, columnKeys) => {
        if (!tbodyElement) return;
        tbodyElement.innerHTML = ''; const colCount = columnKeys.length + 1;
        if (!data || data.length === 0) { tbodyElement.innerHTML = `<tr><td colspan="${colCount}" class="placeholder">Watchlist empty or filter has no match.</td></tr>`; if(watchlistCountSpan) watchlistCountSpan.textContent = '0'; return; }
        const fragment = document.createDocumentFragment();
        data.forEach(item => {
            const row = document.createElement('tr'); row.dataset.name = item.name;
            columnKeys.forEach((key, index) => {
                const cell = row.insertCell();
                if (index === 2) { cell.classList.add('watchlist-name-col'); }
                if (key === 'rating') { cell.innerHTML = renderRatingBar(item[key] ?? 0); cell.classList.add('rating-cell'); }
                else { cell.textContent = item[key] ?? 'N/A'; }
            });
            const actionCell = row.insertCell(); actionCell.classList.add('table-actions');
             actionCell.innerHTML = `<button class="button-icon action-chart" title="Open Chart" data-name="${item.name}"><svg><use xlink:href="#icon-chart"></use></svg></button><button class="button-icon action-copy" title="Copy Name" data-name="${item.name}"><svg><use xlink:href="#icon-copy"></use></svg></button><button class="button-icon action-delete" title="Delete" data-name="${item.name}"><svg><use xlink:href="#icon-delete"></use></svg></button>`;
            // Use already defined handlers
            row.addEventListener('dblclick', handleDoubleClick);
            row.addEventListener('contextmenu', handleContextMenu);
            fragment.appendChild(row);
        });
        tbodyElement.appendChild(fragment);
        if(watchlistCountSpan) watchlistCountSpan.textContent = data.length;
    };

    const getScreenerRowDataForWatchlist = (rowElement) => {
        const cells = rowElement.cells; if (!cells || cells.length < 8) return null;
        const ratingCell = cells[7]; const rating = ratingCell ? (ratingCell.querySelectorAll('.rating-segment.filled')?.length ?? 0) : 0;
        return [ cells[0].textContent, cells[1].textContent, cells[2].textContent, cells[3].textContent, cells[4].textContent, cells[5].textContent, cells[6].textContent, rating ];
      };

    // --- Sorting ---
    const sortTable = (tableId, columnIndex) => {
        const table = document.getElementById(tableId); if (!table) return;
        const tbody = table.tBodies[0]; if (!tbody) return;
        const headerCells = table.tHead.rows[0].cells;
        let rows = Array.from(tbody.rows);
        if (tableId === 'watchlist-table') { rows = rows.filter(row => !row.querySelector('.watchlist-date-header')); }
        if (!rows.length || !headerCells[columnIndex] || headerCells[columnIndex].classList.contains('actions-header')) return;
        const sortType = headerCells[columnIndex].dataset.sort || 'string';
        if (columnIndex === sortColumnIndex && tableId === lastSortedTableId) { sortAscending = !sortAscending; }
        else { sortAscending = true; if (sortColumnIndex !== -1 && lastSortedHeader) { const prevIndicator = lastSortedHeader.querySelector('.sort-indicator'); if(prevIndicator) prevIndicator.className = 'sort-indicator'; } sortColumnIndex = columnIndex; }
        lastSortedTableId = tableId; lastSortedHeader = headerCells[columnIndex];
        Array.from(headerCells).forEach((th, index) => { const indicator = th.querySelector('.sort-indicator'); if (indicator) { indicator.className = `sort-indicator ${index === columnIndex ? (sortAscending ? 'asc' : 'desc') : ''}`; }});
        rows.sort((a, b) => {
            let valA, valB; const ratingColIndexScreener = 7; const ratingColIndexWatchlist = 10;
            const isRatingColumn = (tableId === 'screener-table' && columnIndex === ratingColIndexScreener) || (tableId === 'watchlist-table' && columnIndex === ratingColIndexWatchlist);
            if (isRatingColumn) { valA = a.cells[columnIndex]?.querySelectorAll('.rating-segment.filled').length || 0; valB = b.cells[columnIndex]?.querySelectorAll('.rating-segment.filled').length || 0; }
            else { valA = a.cells[columnIndex]?.textContent.trim() || ''; valB = b.cells[columnIndex]?.textContent.trim() || ''; }
            const isNaA = valA === 'N/A' || valA === ''; const isNaB = valB === 'N/A' || valB === '';
            if (isNaA && isNaB) return 0; if (isNaA) return sortAscending ? 1 : -1; if (isNaB) return sortAscending ? -1 : 1;
            let comparison = 0;
            switch (sortType) {
                case 'numeric': const numA = isRatingColumn ? valA : parseFloat(valA.replace(/[^0-9.-]+/g, '')); const numB = isRatingColumn ? valB : parseFloat(valB.replace(/[^0-9.-]+/g, '')); if (!isNaN(numA) && !isNaN(numB)) { comparison = numA - numB; } else { comparison = String(valA).localeCompare(String(valB)); } break;
                case 'date': try { let dtA, dtB; if (tableId === 'watchlist-table' && columnIndex <= 1) { dtA = new Date(`${a.cells[0]?.textContent}T${a.cells[1]?.textContent}`); dtB = new Date(`${b.cells[0]?.textContent}T${b.cells[1]?.textContent}`); } else { dtA = new Date(valA); dtB = new Date(valB); } if (!isNaN(dtA) && !isNaN(dtB)) { comparison = dtA - dtB; } else { comparison = String(valA).localeCompare(String(valB)); }} catch(e) { comparison = String(valA).localeCompare(String(valB)); } break;
                case 'string': default: comparison = String(valA).localeCompare(String(valB), undefined, { sensitivity: 'base' }); break;
            } return sortAscending ? comparison : -comparison;
        });
        const fragment = document.createDocumentFragment(); rows.forEach(row => fragment.appendChild(row));
        while(tbody.firstChild) { tbody.removeChild(tbody.firstChild); } tbody.appendChild(fragment);
     };
     document.querySelectorAll('.data-table thead th').forEach(th => {
         th.addEventListener('click', () => { const tableId = th.closest('table').id; const columnIndex = parseInt(th.dataset.columnIndex); if (!isNaN(columnIndex) && columnIndex >= 0 && !th.classList.contains('actions-header')) { sortTable(tableId, columnIndex); } else { if (!th.classList.contains('actions-header')) console.warn("Invalid col index or non-sortable header:", th.dataset.columnIndex); } });
      });

    // --- Modals ---
    const showModal = (modalOverlayElement) => modalOverlayElement.classList.add('visible');
    const hideModal = (modalOverlayElement) => modalOverlayElement.classList.remove('visible');
    gradeModalCloseButtons.forEach(button => button.addEventListener('click', () => hideModal(gradeModalOverlay)));
    gradeModalOverlay.addEventListener('click', (event) => { if (event.target === gradeModalOverlay) hideModal(gradeModalOverlay); });
    confirmGradeButton.addEventListener('click', () => { if (activeModalConfirmCallback) activeModalConfirmCallback(); hideModal(gradeModalOverlay); activeModalConfirmCallback = null; });
    chartModalCloseButtons.forEach(button => button.addEventListener('click', () => hideModal(chartModalOverlay)));
    chartModalOverlay.addEventListener('click', (event) => { if (event.target === chartModalOverlay) hideModal(chartModalOverlay); });
    if (infoPanelToggle && infoPanelContainer) {
        infoPanelToggle.addEventListener('click', () => { const isCollapsed = infoPanelContainer.classList.toggle('collapsed'); localStorage.setItem('infoPanelCollapsed', isCollapsed); });
        if (localStorage.getItem('infoPanelCollapsed') === 'true') { infoPanelContainer.classList.add('collapsed'); }
    }

    const formatLabel = (key) => {
        let label = key.replace(/\|240/g, ' (4h)')
                       .replace(/[._]/g, ' ')
                       .replace(/([A-Z]+)([A-Z][a-z])/g, '$1 $2')
                       .replace(/([a-z\d])([A-Z])/g, '$1 $2');
        label = label.replace(/(^|\s)\S/g, l => l.toUpperCase());
        label = label.replace('Rsi', 'RSI').replace('Ema', 'EMA').replace('Atr', 'ATR').replace('Atrp', 'ATRP')
                     .replace('Vwap', 'VWAP').replace('Vwma', 'VWMA')
                     .replace(/(\d+)d Calc/g, '$1d')
                     .replace('Price 52 Week', '52 Week');
        return label;
    };
    const displayPairInfo = (container, data) => {
        if (!container || !data) { if(container) container.innerHTML = '<div class="widget-placeholder">Info N/A</div>'; return; }
        const infoGroups = {
            "Volatility / Volume": ['Volatility.D', 'Volatility.W', 'Volatility.M', 'ATR', 'ATRP', 'volume', 'volume_change', 'Value.Traded', 'average_volume_10d_calc', 'average_volume_30d_calc', 'average_volume_60d_calc', 'average_volume_90d_calc', 'VWAP', 'VWMA'],
            "Performance": ['Perf.5D','Perf.W', 'Perf.1M', 'Perf.3M', 'Perf.6M', 'Perf.YTD', 'Perf.Y', 'Perf.All', 'change|240', 'change'],
            "Levels": ['High.5D','Low.5D', 'High.1M', 'Low.1M', 'High.3M', 'Low.3M', 'High.6M', 'Low.6M', 'price_52_week_high', 'price_52_week_low', 'High.All', 'Low.All']
        };
        let html = '';
        for (const groupName in infoGroups) {
            let groupHtml = '';
            infoGroups[groupName].forEach(key => { if (data.hasOwnProperty(key)) { const value = data[key] ?? 'N/A'; const label = formatLabel(key); groupHtml += `<div class="info-item"><span>${label}:</span><span>${value}</span></div>`; } });
            if (groupHtml) { html += `<div class="info-group"><h4>${groupName}</h4>${groupHtml}</div>`; }
        }
        container.innerHTML = html || '<div class="widget-placeholder">No detailed info available.</div>';
    };
    const showChartModal = (pairName) => {
        if (!pairName) return; if (typeof TradingView === 'undefined' || !TradingView.widget) { updateStatus("Error: Chart library.", true); return; }
        chartModalTitle.textContent = `${pairName} Chart & Info`; chartWidgetContainer.innerHTML = '<div class="widget-placeholder">Loading Chart...</div>'; if(infoPanelContainer) infoPanelContainer.innerHTML = '<div class="widget-placeholder">Loading Info...</div>';
        currentChartSymbol = `BYBIT:${pairName}`;
        const pairData = fullScreenerData.find(item => item.name === pairName) || currentWatchlistData.find(item => item.name === pairName);
        try {
            if (tradingViewChartInstance && typeof tradingViewChartInstance.remove === 'function') { try { tradingViewChartInstance.remove(); } catch (e) { console.warn("Remove chart err:", e); } finally { tradingViewChartInstance = null; } }
            chartWidgetContainer.innerHTML = '';
            tradingViewChartInstance = new TradingView.widget({
                "container_id": "tradingview-widget-container-dynamic", "autosize": true, "symbol": currentChartSymbol, "interval": "240", "timezone": "Etc/UTC", "theme": "dark", "style": "1", "locale": "en", "enable_publishing": false, "hide_side_toolbar": true, "hide_legend": true, "allow_symbol_change": true, "gridColor": "rgba(0, 0, 0, 0.06)", "save_image": false,
                "studies": [ { "id": "MAExp@tv-basicstudies", "inputs": { "length": 100 } }, { "id": "RSI@tv-basicstudies", "inputs": { "length": 14 } } ], "support_host": "https://www.tradingview.com"
            });
        } catch (error) { console.error("Chart Widget err:", error); updateStatus("Error chart.", true); chartWidgetContainer.innerHTML = '<div class="widget-placeholder">Error loading chart.</div>'; }
        displayPairInfo(infoPanelContainer, pairData);
        if (openTvSiteButton) openTvSiteButton.href = `https://www.tradingview.com/chart/?symbol=${encodeURIComponent(currentChartSymbol)}`;
        if (localStorage.getItem('infoPanelCollapsed') === 'true') { infoPanelContainer?.classList.add('collapsed'); } else { infoPanelContainer?.classList.remove('collapsed'); }
        showModal(chartModalOverlay);
    };

    // --- Event Listeners ---
    tabNav.addEventListener('click', (event) => {
        const clickedTab = event.target.closest('.tab-link');
        if (!clickedTab || clickedTab.classList.contains('active')) return;
        if (clickedTab.dataset.tabTarget === '#watchlist-tab-pane' && !IS_AUTHENTICATED) { window.location.href = '/login'; return; }
        tabLinks.forEach(link => link.classList.remove('active'));
        tabPanels.forEach(panel => panel.classList.remove('active'));
        clickedTab.classList.add('active');
        const targetPanelId = clickedTab.dataset.tabTarget;
        const targetPanel = document.querySelector(targetPanelId);
        if (targetPanel) targetPanel.classList.add('active');
    });
    // Attach listeners to screener table body (always exists)
    screenerTableBody.addEventListener('click', async (event) => {
        const addButton = event.target.closest('.action-add:not([disabled])');
        const chartButton = event.target.closest('.action-chart');
        const targetRow = event.target.closest('tr'); if (!targetRow) return;
        if (addButton) {
             const pairName = addButton.dataset.name; const itemData = getScreenerRowDataForWatchlist(targetRow);
             if (itemData && pairName) { gradeModalItemName.textContent = pairName; activeModalConfirmCallback = async () => { const grade = gradeSelect.value; const result = await fetchData('/watchlist/add', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ itemData: itemData, grade: grade }) }); if (result?.success) { updateStatus(result.message); if (IS_AUTHENTICATED) loadWatchlist(); } else { updateStatus(result?.message || 'Add failed.', true); } }; showModal(gradeModalOverlay); }
             else { updateStatus("Could not get data.", true); }
        }
        else if (chartButton) { const pairName = chartButton.dataset.name; if (pairName) { showChartModal(pairName); } }
    });
    contextMenu.addEventListener('click', async (event) => {
        const targetLi = event.target.closest('li'); if (!targetLi || !contextTargetRow) return; const action = targetLi.dataset.action; const pairName = contextTargetRow.dataset.name; if (!action || !pairName) return; hideContextMenu();
        switch (action) {
            case 'open-tv': showChartModal(pairName); break;
            case 'add-watchlist':
                if (!IS_AUTHENTICATED) { updateStatus("Please log in to add items.", "warning"); return; }
                const itemData = getScreenerRowDataForWatchlist(contextTargetRow);
                if (itemData) { gradeModalItemName.textContent = pairName; activeModalConfirmCallback = async () => { const grade = gradeSelect.value; const result = await fetchData('/watchlist/add', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ itemData: itemData, grade: grade }) }); if (result?.success) { updateStatus(result.message); if (IS_AUTHENTICATED) loadWatchlist(); } else { updateStatus(result?.message || 'Add failed.', true); } }; showModal(gradeModalOverlay); }
                else { updateStatus("Could not get data.", true); }
                break;
            case 'copy-name': navigator.clipboard.writeText(pairName).then(() => updateStatus(`Copied ${pairName}.`)).catch(err => updateStatus(`Copy failed.`, true)); break;
            case 'delete-watchlist':
                if (!IS_AUTHENTICATED) { updateStatus("Please log in to manage watchlist.", "warning"); return; }
                if (confirm(`Delete ${pairName}?`)) { const result = await fetchData('/watchlist/delete', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name: pairName }) }); if (result?.success) { updateStatus(result.message); if (IS_AUTHENTICATED) loadWatchlist(); } else { updateStatus(result?.message || 'Delete failed.', true); } }
                break;
            default: console.warn("Unknown action:", action);
        }
     });
    applyAlphaFilterButton.addEventListener('click', async () => {
         const criteria = { ema4hr: document.getElementById('alpha-ema-4hr').value, rsi4hr: document.getElementById('alpha-rsi-4hr').value, emaDaily: document.getElementById('alpha-ema-daily').value, rsiDaily: document.getElementById('alpha-rsi-daily').value };
         const result = await fetchData('/filter/alpha', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(criteria) });
         const screenerColumns = ['name', 'close|240', 'volume', 'RSI|240', 'RSI', 'EMA_Class_4hr', 'EMA_Class_Daily', 'rating'];
         if (result?.data) {
             fullScreenerData = result.data; populateScreenerTable(screenerTableBody, fullScreenerData, screenerColumns); updateTickerTape();
             const message = `Filter applied. ${fullScreenerData.length} results found.`; updateStatus(message, fullScreenerData.length === 0);
             if (fullScreenerData.length > 0) { const screenerTabLink = tabNav.querySelector('[data-tab-target="#screener-tab-pane"]'); if (screenerTabLink) screenerTabLink.click(); }
         } else { fullScreenerData = []; populateScreenerTable(screenerTableBody, [], screenerColumns); updateTickerTape(); updateStatus(result?.error || 'Filter failed.', true); }
     });
    if (tickerViewModeSelect) { tickerViewModeSelect.addEventListener('change', updateTickerTape); }
    refreshDataButton.addEventListener('click', async () => {
        if (!IS_AUTHENTICATED) { updateStatus("Please log in to refresh data.", "warning"); return; }
        updateStatus("Refreshing data...");
        const result = await fetchData('/data/refresh', { method: 'POST' });
        if (result) { updateStatus(result.message + " Wait..."); setTimeout(loadInitialScreenerData, 15000); }
        else { updateStatus("Refresh failed.", true); }
    });

    // --- Watchlist Controls Event Listeners (conditionally attached) ---
    if (IS_AUTHENTICATED) {
        const applyWatchlistFilter = () => {
            if (!watchlistFilterInput || !watchlistTableBody) return;
            const filterDate = watchlistFilterInput.value; // Get value directly
            const watchlistColumns = ["date_added", "time_added", "name", "price", "volume", "rsi_4hr", "rsi_d", "ema_4hr", "ema_d", "grade", "rating"];
            const filteredData = filterDate ? currentWatchlistData.filter(item => item.date_added === filterDate) : currentWatchlistData;
            populateWatchlistTable(watchlistTableBody, filteredData, watchlistColumns);
        };

        if (watchlistFilterInput) {
            watchlistFilterInput.addEventListener('change', applyWatchlistFilter);
        }
        if (watchlistClearFilterButton) {
            watchlistClearFilterButton.addEventListener('click', () => {
                if(watchlistFilterInput) watchlistFilterInput.value = '';
                applyWatchlistFilter();
            });
        }
        if(copyWatchlistButton){
            copyWatchlistButton.addEventListener('click', async () => {
                 const result = await fetchData('/watchlist/copy_data');
                 if (result?.success && typeof result.text === 'string') { navigator.clipboard.writeText(result.text).then(() => updateStatus('Copied.')).catch(err => updateStatus('Copy failed.', true)); }
                 else { updateStatus(result?.message || 'Copy failed.', true); }
             });
        }
        if(deleteAllWatchlistButton) {
             deleteAllWatchlistButton.addEventListener('click', async () => {
                 if (confirm('Delete ALL watchlist items?')) { const result = await fetchData('/watchlist/delete_all', { method: 'POST' }); if (result?.success) { updateStatus(result.message); if (IS_AUTHENTICATED) loadWatchlist(); } else { updateStatus(result?.message || 'Delete failed.', true); } }
             });
        }
        if (watchlistTableBody) { // Add listener only if table exists
            watchlistTableBody.addEventListener('click', async (event) => {
                if (!IS_AUTHENTICATED) return;
                const chartButton = event.target.closest('.action-chart');
                const copyButton = event.target.closest('.action-copy');
                const deleteButton = event.target.closest('.action-delete');
                const targetRow = event.target.closest('tr');
                if (chartButton && targetRow) { const pairName = chartButton.dataset.name; if (pairName) { showChartModal(pairName); } }
                else if (copyButton && targetRow) { const pairName = copyButton.dataset.name; if (pairName) { navigator.clipboard.writeText(pairName).then(() => updateStatus(`Copied ${pairName}.`)).catch(err => updateStatus(`Copy failed.`, true)); } }
                else if (deleteButton && targetRow) {
                    const pairName = deleteButton.dataset.name;
                    if (pairName) { if (confirm(`Delete ${pairName}?`)) { const result = await fetchData('/watchlist/delete', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name: pairName }) }); if (result?.success) { updateStatus(result.message); if (IS_AUTHENTICATED) loadWatchlist(); } else { updateStatus(result?.message || 'Delete failed.', true); } } }
                    else { console.error("Could not find data-name on delete button:", deleteButton); updateStatus("Could not identify item to delete.", true); }
                }
            });
        }
    }

    // --- Data Loading ---
    const loadWatchlist = async () => {
        if (!IS_AUTHENTICATED || !watchlistTableBody) {
            if (watchlistCountSpan) watchlistCountSpan.textContent = '0';
            return;
        }
        const result = await fetchData('/watchlist');
        const watchlistColumns = ["date_added", "time_added", "name", "price", "volume", "rsi_4hr", "rsi_d", "ema_4hr", "ema_d", "grade", "rating"];
        if (result?.data) {
             currentWatchlistData = result.data;
             // Directly populate after fetch. Filtering is handled by event listeners.
             populateWatchlistTable(watchlistTableBody, currentWatchlistData, watchlistColumns);
             if (watchlistCountSpan) watchlistCountSpan.textContent = currentWatchlistData.length;
             // If a date filter was already set, apply it now
             if (watchlistFilterInput && watchlistFilterInput.value) {
                 const applyWatchlistFilter = () => { // Re-scope function if needed
                     if (!watchlistFilterInput || !watchlistTableBody) return;
                     const filterDate = watchlistFilterInput.value;
                     const filteredData = filterDate ? currentWatchlistData.filter(item => item.date_added === filterDate) : currentWatchlistData;
                     populateWatchlistTable(watchlistTableBody, filteredData, watchlistColumns);
                 };
                 applyWatchlistFilter();
             }
        }
        else { currentWatchlistData = []; populateWatchlistTable(watchlistTableBody, [], watchlistColumns); if (watchlistCountSpan) watchlistCountSpan.textContent = '0'; }
     };
    const loadInitialScreenerData = async () => {
         const result = await fetchData('/data/screener');
         const screenerColumns = ['name', 'close|240', 'volume', 'RSI|240', 'RSI', 'EMA_Class_4hr', 'EMA_Class_Daily', 'rating'];
         if (result?.data) { fullScreenerData = result.data; populateScreenerTable(screenerTableBody, fullScreenerData, screenerColumns); updateTickerTape(); updateStatus('Screener data loaded.'); }
         else { fullScreenerData = []; populateScreenerTable(screenerTableBody, [], screenerColumns); updateTickerTape(); updateStatus(result?.error || 'Load failed.', true); }
     };

    loadInitialScreenerData();
    loadWatchlist();
});